### 什么情况下会发生栈内存溢出。

- 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 **StackOverflowError** 异常，**方法递归调用**产生这种结果。
- 如果 Java 虚拟机栈可以**动态扩展**，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么 Java 虚拟机将抛出一个 **OutOfMemoryError** 异常。(线程启动过多)
- 参数 -Xss 去调整 JVM 栈的大小

###  JVM 内存模型

![JVM 内存模型](https://gitee.com/leeyhDev/TyporaImages/raw/master/images/202006272140-397085.jpeg)

- **程序计数器**：内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码**指令的地址**；如果正在执行的是 Native 方法，这个计数器的值则为 ( **Undefined** )。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 **OutOfMemoryError** 情况的区域。

- **Java 虚拟机栈**：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧  ( Stack Frame ) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

  局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)。StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
  OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

- **本地方法栈**：区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 **StackOverflowError** 和 **OutOfMemoryError** 异常。

- **Java 堆**：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。

  **OutOfMemoryError**：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。

- **方法区**：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久代），回收目标主要是常量池的回收和类型的卸载，各线程共享。

### JVM 内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为 Eden 和 Survivor。一次完整的 GC 流程是怎样的，对象如何晋升到老年代。

共享内存区划分

- 共享内存区 = 非堆内存（持久代，永久代，元空间） + 堆内存
- 非堆内存：在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是**方法区的实现**，他们最大区别是：元空间并不在 JVM 中，而是使用本地内存。
- Java 堆 =  新生代 （年轻代，Young Generation）+ 老年代 （Old Generation）（**1:2**）
- 新生代 = Eden + Survivor 0 + Survivor 1（ **8:1:1** ）

一些参数的配置

- 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
- 默认的，Edem : from : to = 8 : 1 : 1 (可以通过参数 –XX: SurvivorRatio 来设定)
- Survivor区中的对象被复制次数为15 (对应虚拟机参数 -XX:+MaxTenuringThreshold)

一次完整的 GC 流程

- 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
- **大对象**（需要大量连续内存空间的Java对象，如那种很长的字符串，数组）**直接进入老年代**；
- 如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为1，每熬过一次 Minor GC，年龄+1，**若年龄超过一定限制（15），则被晋升到老年态**。即**长期存活的对象进入老年代**。
- 老年代满了而**无法容纳更多的对象**，Minor GC 之后通常就会进行 Full GC，Full GC  清理整个内存堆 – **包括年轻代和年老代**。
- Major GC **发生在老年代的GC**，**清理老年区**，经常会伴随至少一次 Minor GC，**比 Minor GC 慢10倍以上**。

为什么要分为 Eden 和 Survivor ?为什么要设置两个 Survivor 区？

- 如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发 Major GC。老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC 长得多，所以需要分为 Eden 和 Survivor。
- Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
- 设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

### 如和判断一个对象是否存活（GC 的两种判定方法）?

判断一个对象是否存活有两种方法:
- 引用计数法
  所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收。引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

- 可达性算法(引用链法)
     该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
       在 java 中可以作为 GC Roots 的对象有以下几种: 
- 虚拟机栈中引用的对象 
  
- 方法区类静态属性引用的对象 
  
- 方法区常量池引用的对象 
  
- 本地方法栈 JNI 引用的对象

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记    如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果inalize()执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。

### java 中垃圾收集的方法有哪些?

1. 标记-清除:
这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：
1. 效率不高，标记和清除的效率都很低
2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。
2. 复制算法（年轻代）:
    为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)
3. 标记-整理（标记-压缩）算法：
    该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
4. 分代收集
    现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

### SafePoint 是什么？

比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC，
1. 循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入safepoint)
2. 方法返回前
3. 调用方法的 call 之后
4. 抛出异常的位置

### 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

几种垃圾收集器：

- **Serial收集器：** 单线程的收集器，收集垃圾时，必须 stop the world，使用复制算法。
- **ParNew收集器：**  Serial收集器的多线程版本，也需要 stop the world，复制算法。
- **Parallel Scavenge收集器：** 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
- **Serial Old收集器：** 是 Serial 收集器的老年代版本，单线程收集器，使用标记整理算法。
- **Parallel Old收集器：** 是 Parallel Scavenge 收集器的老年代版本，使用多线程，标记-整理算法。
- **CMS(Concurrent Mark Sweep) 收集器：** 是一种以获得最短回收停顿时间为目标的收集器，**标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除**，收集结束会产生大量空间碎片。
- **G1收集器：** 标记整理算法实现，**运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记**。不会产生空间碎片，可以精确地控制停顿。

CMS收集器和G1收集器的区别：

- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
- G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
- CMS收集器以最小的停顿时间为目标的收集器；
- G1收集器可预测垃圾回收的停顿时间
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 简述 java 内存分配与回收策略？Minor GC 与 MajorGC (FullGC) 分别在什么时候发生？

程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。

1. **年轻代的策略**：对象优先在 Eden 分配，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。分配对象时，假如Eden区没有足够空间容纳该对象时，虚拟机将发起一次Minor GC，经过这次GC，Eden区中仍然存活的对象将被转移到Survivor区，并且年龄对象设置为1，如果Survivor区也无法容纳从Eden区转移过来的对象，就会通过分配担保机制提前转移到老年代去。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。

2. **大对象的策略**：大对象（Eden 无法容纳）直接进入老年代，如果老年代空间也不足就会触发 Full GC。虚拟机提供了一个  -XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。由于新生代采用复制算法收集内存，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。

   **注意**　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。

3.  **晋升策略**：年轻代的对象每熬过一次 Minor GC，年龄就加一岁，默认15岁时，就会进入老年代。不过这个条件并非绝对，如果 Survivor 中相同年龄的对象总和大于 Survivor 空间的一半，那么年龄大于等于该年龄的对象可以直接晋升到老年代。Eden 触发 YGC 后幸存下来的而 Survivor 无法容纳的会直接进入老年代。

4. **空间分配担保**：年轻代在Minor GC后会有对象进入老年代，在极端情况下，年轻代所有对象都存活并进入老年代。所以在MinorGC之前，虚拟机会检查老年代的连续内存空间是否大于年轻代所有对象总和。如果空间不够，那么这次MinorGC是有风险的。如果允许冒险，Minor GC会直接执行，如果失败，会再发起一次full GC。如果不允许冒险，则先执行一次 full GC，再进行 Minor GC。通常会把HandlePromotionFailure开关打开，以减少Full GC。

**回收策略以及Minor GC 和 Major GC(Full GC)**

Minor GC（young GC）：当年轻代中的eden区分配满的时候触发。由于java对象大都是朝生夕死的，所以Minor GC非常频繁，一般回收速度也比较快。注意young GC中有部分存活对象会晋升到 old gen，所以young GC后old gen的占用量通常会有所升高。一般采用复制算法。

MajorGC：是清理老年代，Major GC发生过程常常伴随一次Minor GC。

FullGC：Full GC可以看做是Major GC+Minor GC共同进行的一整个过程，是清理整个堆空间（包括年轻代和老年代，这里不包含永久代，因为永久代在JDK7之前包含方法区，是一块与堆分离的区域；JDK7将静态变量从永久代移到堆中；JDK8则完全取消永久代，方法区存在元空间MetaSpace中，虽然与堆共享一块内存，逻辑上可以认为在堆中，但仍然与堆不相连）。Full GC的速度一般会比 Minor GC慢10倍以上。一般用的是标记整理和标记清除算法。发生GC有两种情况，①当老年代无法分配内存的时候，会导致MinorGC ②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生Full GC。

Full GC触发条件

- Minor GC时介绍中Survivor空间不足时，判断是否允许担保失败，如果不允许则进行Full GC。如果允许，并且每次晋升到老年代的对象平均大小>老年代最大可用连续内存空间，也会进行Full GC。
- Minor GC后存活的对象超过了老年代剩余空间
- 方法区内存不足时
- System.gc()，可用通过-XX:+ DisableExplicitGC来禁止调用System.gc
- CMS GC异常，CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，会触发Full GC

### GC 是什么? 为什么要有 GC?

GC就是垃圾回收，释放掉没用的对象占用的空间，保证内存空间不被迅速耗尽。

### 简单说一下java的垃圾回收机制。

java采用分代回收，分为年轻代、老年代、永久代。年轻代又分为E区、S1区、S2区。到jdk1.8，永久代被元空间取代了。年轻代都使用复制算法，老年代的收集算法看具体用什么收集器。默认是PS收集器，采用标记-整理算法。

### JVM的常见垃圾回收算法有哪些？

复制、标记清除、标记整理、分代回收

### 为什么要使用分代回收机制？

因为没有一种算法能适用所有场合。在对象存活率低的场景下，复制算法最合适。

对象存活率高时，标记清除或者标记整理算法最合适。

所以才需要分代来处理。

### 如何判断一个对象是否存活?

现在主流使用的都是可达性分析法。从GC Roots对象计算引用链，能链上的就是存活的。

### 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存?

不会。对象回收需要一个过程，这个过程中对象还能复活。而且垃圾回收具有不确定性，指不定什么时候开始回收。
### 强引用、软引用、弱引用、虚引用的区别？

- 强引用：我们平时new了一个对象就是强引用，例如 Object obj = new Object()；即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
- 软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

- 弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
- 虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### JMM ( Java ) 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。

Java内存模型图：

![img](https://user-gold-cdn.xitu.io/2019/7/23/16c1c1982e3609b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



Java内存模型规定了所有的**变量都存储在主内存**中，每条**线程还有自己的工作内存**，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，**线程对变量的所有操作都必须在工作内存中**进行，**而不能直接读写主内存**。不同的线程之间也**无法直接访问对方工作内存中的变量**，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

指令重排序。

在这里，先看一段代码

```
public class PossibleReordering {
static int x = 0, y = 0;
static int a = 0, b = 0;

public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new Runnable() {
        public void run() {
            a = 1;
            x = b;
        }
    });

    Thread other = new Thread(new Runnable() {
        public void run() {
            b = 1;
            y = a;
        }
    });
    one.start();other.start();
    one.join();other.join();
    System.out.println(“(” + x + “,” + y + “)”);
}
复制代码
```

运行结果可能为(1,0)、(0,1)或(1,1)，也可能是(0,0)。因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是**指令重排**。

内存屏障

**内存屏障**，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。

- **LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- **StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- **LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- **StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

happen-before原则

- **单线程happen-before原则**：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
- **volatile的happen-before原则**：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。
- **happen-before的传递性原则**：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
- **线程启动的happen-before原则**：同一个线程的start方法happen-before此线程的其它方法。
- **线程中断的happen-before原则** ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
- **线程终结的happen-before原则：** 线程中的所有操作都happen-before线程的终止检测。
- **对象创建的happen-before原则：** 一个对象的初始化完成先于他的finalize方法调用。

### 什么是类加载器，类加载器有哪些？可以打破双亲委派么，怎么打破？

什么是类加载器？

**类加载器** 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

> - 启动类加载器（Bootstrap  ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
> - 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
>
> > - 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
> > - 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

双亲委派模型

**双亲委派模型工作过程是：**

> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

双亲委派模型图：



![img](https://user-gold-cdn.xitu.io/2019/7/23/16c1c54cf4ad886b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



为什么需要双亲委派模型？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以**自己定义一个java.lang.Object的同名类**，**java.lang.String的同名类**，并把它放到ClassPath中,那么**类之间的比较结果及类的唯一性将无法保证**，因此，为什么需要双亲委派模型？**防止类的重复加载，内存中出现多份同样的字节码**，保护程序安全，防止核心的Java语言环境遭到破坏

怎么打破双亲委派模型？

打破双亲委派机制则不仅**要继承ClassLoader**类，还要**重写loadClass和findClass**方法。

### 引起类加载操作的行为（类初始化时机）

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令（创建类的实例）
- 访问类的静态变量或者对静态变量进行赋值，调用静态方法
- 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
- 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化
- class.forName("包类名")
- 虚拟机执行主类的时候(有 main 方法或者 test 方法)

### Java对象创建方法

- 使用new关键字创建对象
- 使用Class类的newInstance方法(反射机制)
- 使用Constructor类的newInstance方法(反射机制)
- 使用Clone方法创建对象
- 使用(反)序列化机制创建对象

### Java创建对象的步骤

- 判断对象对应的类是否加载、链接、初始化
- 为对象分配内存
- 处理并发安全问题
- 初始化分配到的空间
- 设置对象的对象头
- 执行init方法进行初始化

### 简述 java 类加载机制

### 类加载的几个过程

### 对象创建方法，对象的内存分配，对象的访问定位

